BEE Project - Comprehensive Functionality & Technology Report
üìã Project Overview
A real-time hospital appointment management system built with Node.js, Express.js, EJS, PostgreSQL, Redis Cloud, and Socket.IO WebSockets.

üéØ Core Functionalities
1. User Authentication & Authorization
Patient Authentication
Registration System

Name, contact, and password fields
Password hashing using bcrypt (10 salt rounds)
Unique contact constraint validation
Form validation with error handling
Login System

Session-based authentication using express-session
Password verification with bcrypt.compare()
Session storage: patient ID, name, and contact
Session expiry: 2 hours
Automatic redirect to patient dashboard on success
Doctor Authentication
Registration System

Fields: name, specialization, contact, schedule, password
Bcrypt password hashing (10 salt rounds)
Redirect to login page after successful registration
Login System

Session-based authentication
Session storage: doctor ID and name
Bcrypt password verification
Redirect to doctor dashboard on success
Error handling with user-friendly messages
2. Patient Features
Dashboard System
Main Dashboard (/patients/dashboard)
Displays patient name from session
Lists all available medical specializations (dynamically fetched from database)
Specializations retrieved via PostgreSQL DISTINCT query
Clean, user-friendly interface
Doctor Search & Filtering
Specialization-based Doctor Listing (/patients/dashboard/:specialization)
Displays all doctors for selected specialization
Shows doctor details: name, contact, specialization, schedule
"Book Appointment" button for each doctor
Session-protected route (patientAuth middleware)
Appointment Booking System
Booking Form (/patients/book-appointment/:doctorId)

Date picker for appointment date
Time range selection (start time and end time)
Doctor information display
Session validation before booking
Double Booking Prevention

PostgreSQL query to check time slot conflicts
Logic: NOT (new_end <= existing_start OR new_start >= existing_end)
Error message if slot is already booked
Returns to booking form with error feedback
Appointment Creation

Inserts appointment with status 'pending'
Stores: patient_id, doctor_id, date, start_time, end_time, status
Generates unique appointment ID
Redirects to confirmation page
Appointment Confirmation
Confirmation Page (/patients/appointment-confirmation/:appointmentId)
Displays patient name
Shows doctor name and specialization
Appointment date and time slot
Status badge (pending/accepted/rejected)
Join query across appointments, doctors, and patients tables
Appointment Management
My Appointments (/patients/my-appointments)
Lists all patient's appointments (past and upcoming)
Ordered by date (descending) and time
Shows: doctor name, specialization, date, time, status
Color-coded status badges:
Pending: Yellow/Orange
Accepted: Green
Rejected: Red
Real-time status updates via WebSocket
Auto-refresh when status changes (no page reload needed)
3. Doctor Features
Doctor Dashboard
Dashboard Overview (/doctors/dashboard)

Displays doctor's name from session
Lists all appointments for the doctor
Ordered by date and time
Shows patient details for each appointment
Status-based filtering (pending appointments highlighted)
Redis Caching Layer (Currently implemented, ready to use)

Cache key format: appointments:{doctorId}
Cache expiration: 45-60 seconds TTL
Cache invalidation on new appointments or status changes
Fallback to PostgreSQL on cache miss
Automatic cache warming after database query
Appointment Request Management
Accept Appointment (/doctors/accept-appointment/:id)

Updates appointment status to 'accepted' in PostgreSQL
Invalidates Redis cache for the doctor
Publishes appointment:updated event to Redis Pub/Sub
Real-time notification sent to patient via WebSocket
Session-protected route (doctorAuth middleware)
Reject Appointment (/doctors/reject-appointment/:id)

Updates appointment status to 'rejected' in PostgreSQL
Cache invalidation
Redis Pub/Sub event publishing
Real-time patient notification
Transaction safety with error handling
4. Real-Time Features
WebSocket Integration (Socket.IO)
Server-Side Setup

HTTP server wrapped with Socket.IO
Connection tracking with client count logging
Event broadcasting to all connected clients
Connection/disconnection event handlers
Events

appointmentBooked: New appointment creation notification
appointmentStatusUpdated: Status change notification
Real-Time Updates
Doctor Dashboard Real-Time

New appointments appear instantly without refresh
Dynamic table row insertion
Green highlight animation for new appointments (3-second fade)
Plays system notification sound (optional)
Shows appointment details: patient name, date, time, status
Auto-scrolls to new appointment
Patient Appointments Real-Time

Status updates appear instantly
Color transition animation (yellow ‚Üí green/red)
Status badge text update
Optional browser notification support
Informational console logs for debugging
5. Redis Cloud Integration
Redis Configuration
Cloud Provider: Redis Labs (Redis Cloud)
Connection Details:
Host: redis-12116.c98.us-east-1-4.ec2.cloud.redislabs.com
Port: 12116
Username: default
Password: (secured)
Connect timeout: 10 seconds
Reconnect strategy: Exponential backoff (max 3 retries)
Three Redis Clients
Cache Client (redisClient)

Purpose: Store frequently accessed data
Cache key pattern: appointments:{doctorId}
TTL: 45-60 seconds
Operations: GET, SET, DEL
Publisher Client (redisPublisher)

Purpose: Publish events to Redis channels
Channels:
appointment:created
appointment:updated
Message format: JSON string
Subscriber Client (redisSubscriber)

Purpose: Listen to Redis channels
Event handlers:
On appointment:created: Broadcast to Socket.IO
On appointment:updated: Broadcast to Socket.IO
Acts as bridge between Redis and WebSocket
Redis Pub/Sub Architecture
Cache Invalidation Strategy
Trigger Points:

New appointment created ‚Üí Delete appointments:{doctorId}
Appointment status updated ‚Üí Delete appointments:{doctorId}
Ensures data consistency between Redis and PostgreSQL
Fallback Mechanism:

If Redis unavailable: Direct Socket.IO emit
No service disruption if Redis fails
Console warnings logged for monitoring
6. Database (PostgreSQL)
Tables Schema
Patients Table

Doctors Table

Appointments Table

Database Operations
Connection Pooling: pg.Pool for efficient connection management
Error Handling: Try-catch blocks with error logging
Transaction Safety: Client release in finally blocks
Parameterized Queries: Protection against SQL injection
Foreign Keys: Referential integrity constraints
üõ†Ô∏è Technologies & Tools Used
Backend Technologies
Node.js (v20.18.0)

JavaScript runtime environment
Event-driven, non-blocking I/O
NPM package management
Express.js (v4.x)

Web application framework
Routing and middleware
Static file serving
Session management
PostgreSQL (Database)

Relational database
ACID compliance
Foreign key constraints
Connection pooling via pg module
Redis Cloud

In-memory data store
Pub/Sub messaging
Caching layer (TTL-based expiration)
Cloud-hosted (Redis Labs)
Socket.IO (v4.x)

Real-time bidirectional communication
WebSocket protocol
Event-based messaging
Automatic reconnection
Security & Authentication
bcryptjs (v2.x)

Password hashing algorithm
Salt generation (10 rounds)
Secure password comparison
Prevents rainbow table attacks
express-session

Server-side session storage
Session cookies
CSRF protection
Configurable expiration
dotenv

Environment variable management
Configuration security
Separates secrets from code
Frontend Technologies
EJS (Embedded JavaScript)

Server-side templating
Dynamic HTML rendering
Partials and includes
JavaScript logic in templates
Vanilla JavaScript

DOM manipulation
Event listeners
Async/await for API calls
No frontend frameworks
CSS3

Custom stylesheets
Responsive design
Animations (status update transitions)
Flexbox/Grid layouts
Middleware & Libraries
express.json(): Parse JSON request bodies
express.urlencoded(): Parse form data
express.static(): Serve CSS, JS, images
Custom Middleware:
patientAuth.js: Patient session validation
doctorAuth.js: Doctor session validation
jwtAuth.js: JWT verification (optional API routes)
Development Tools
nodemon (Development)

Auto-restart on file changes
Hot reloading
concurrently (Development)

Run multiple npm scripts
Start server and client simultaneously
üìä Architecture & Flow
System Architecture
Data Flow - Appointment Booking
Patient fills booking form (EJS)
POST request to /patients/book-appointment/:doctorId
patientAuth middleware validates session
Check for double booking (PostgreSQL query)
Insert appointment with status 'pending'
Delete Redis cache (appointments:{doctorId})
Publish to Redis (appointment:created channel)
Redis Subscriber receives event
Socket.IO broadcasts appointmentBooked
Doctor's browser receives WebSocket event
JavaScript dynamically adds row to table
Patient redirected to confirmation page
Data Flow - Appointment Status Update
Doctor clicks Accept/Reject button
POST to /doctors/accept-appointment/:id or /reject-appointment/:id
doctorAuth middleware validates doctor session
Update appointment status in PostgreSQL
Delete Redis cache (appointments:{doctorId})
Publish to Redis (appointment:updated channel)
Redis Subscriber receives event
Socket.IO broadcasts appointmentStatusUpdated
Patient's browser receives WebSocket event
JavaScript updates status badge and color
Doctor redirected back to dashboard
üîê Security Features
Password Security

Bcrypt hashing (cost factor: 10)
No plain text storage
Secure comparison (timing-safe)
Session Security

HTTP-only cookies
Session secret from environment variables
2-hour session expiration
Session validation middleware
SQL Injection Prevention

Parameterized queries ($1, $2 placeholders)
pg library automatic escaping
Input Validation

Required field checks
Email/contact format validation
Error handling for invalid data
Error Handling

Try-catch blocks throughout
User-friendly error messages
Detailed server logs for debugging
No sensitive data exposed in errors
üìà Performance Optimizations
Redis Caching

Reduces database load
Sub-millisecond response times for cache hits
TTL-based expiration (45-60s)
Cache warming strategy
Connection Pooling

PostgreSQL connection reuse
Reduced connection overhead
Idle connection management
Redis Pub/Sub

Decouples real-time messaging
Scales better than direct WebSocket broadcasting
Message queue for reliability
Asynchronous Operations

Non-blocking I/O
Async/await for database queries
Promise-based Redis operations
üöÄ Additional Features to Include in Report
1. Scalability Considerations
Redis Cloud allows horizontal scaling
WebSocket rooms can be implemented for targeted broadcasts
Database indexes on frequently queried columns (doctor_id, patient_id)
Potential for microservices architecture
2. Future Enhancements
Email notifications for appointment confirmations
SMS reminders using Twilio
Calendar integration (Google Calendar API)
Doctor availability scheduling
Appointment rescheduling
Cancellation feature
Payment gateway integration
Medical records upload
Video consultation feature
Multi-language support
Mobile app (React Native)
Analytics dashboard for admin
3. Monitoring & Logging
Console logging for debugging
Redis connection status tracking
Socket.IO client count monitoring
Database query performance logs
Error tracking (could integrate Sentry)
4. Testing Strategy (Recommended)
Unit tests (Jest)
Integration tests (Supertest)
End-to-end tests (Cypress)
Load testing (Artillery, k6)
Redis cache hit/miss ratio analysis
5. Deployment Considerations
Environment-based configuration (.env files)
Redis Cloud (production-ready)
Heroku/AWS/DigitalOcean deployment
PostgreSQL hosted database (RDS, Heroku Postgres)
SSL/TLS certificates for HTTPS
Reverse proxy (Nginx)
Process manager (PM2)
Docker containerization (optional)
6. API Documentation (If API routes exist)
RESTful API endpoints
Request/response examples
Error codes and messages
Authentication requirements
7. User Experience (UX) Features
Responsive design (mobile-friendly)
Loading indicators
Toast notifications
Form validation with real-time feedback
Accessible UI (ARIA labels)
Keyboard navigation support
üìù Project Structure
üéì Key Learning Outcomes
Full-Stack Development

Frontend (EJS, CSS, JavaScript)
Backend (Node.js, Express.js)
Database (PostgreSQL)
Real-Time Communication

WebSocket protocol understanding
Socket.IO event-driven architecture
Bidirectional data flow
Caching & Performance

Redis in-memory caching
Cache invalidation strategies
Pub/Sub messaging patterns
Security Best Practices

Password hashing
Session management
SQL injection prevention
System Design

Event-driven architecture
Separation of concerns (MVC pattern)
Scalable architecture design
This comprehensive report covers all aspects of your hospital appointment management system, highlighting the technologies, features, and architectural decisions that make it a robust real-time application.